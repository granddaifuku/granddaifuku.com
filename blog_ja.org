#+hugo_base_dir: .
#+hugo_section: /posts
#+author: Yudai Fukushima
#+hugo_auto_set_lastmod: t
#+OPTIONS: \n:t
#+SETUPFILE: /Users/yufuku/org/org-macros/org/org-macros.setup

* Blog Ideas
  :PROPERTIES:
  :VISIBILITY: children
  :END:
  
** DONE Codeforces #713(Div.3) <br> E: Permutation by Sum :@Codeforces:
   :PROPERTIES:
   :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml
   :EXPORT_FILE_NAME: cf-713-div3-e.jp.md
   :EXPORT_DATE: 2021-05-07
   :EXPORT_HUGO_LASTMOD: 2021-05-07
   :EXPORT_HUGO_SECTION*: Competitive
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :thumbnail "images/cf.png"
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Codeforces #713 E 解説"
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :math true
   :END:
   #+BEGIN_SRC yaml :front_matter_extra t
menu:
  sidebar:
    name: Codeforces 713 E
    identifier: cf-713-e-jp
    parent: competitive-jp
    weight: 10
author:
  name: Yudai Fukushima
  image: /images/cf.png
	#+END_SRC
   
*** 問題概要
	- 1 から $n$ までの順列 $P$ を考える
	- $1 \leq l \leq r \leq n$ の $l, r$, $1 \leq s \leq \frac{n(n + 1)}{2}$ の $s$ が与えられる
	- $P_{l} + P_{l + 1} + ... + P_{r} = s$ となる 1 から $n$ までの順列が存在するならばそれを出力、存在しないならば -1 を出力する
	  
*** 解説
	1 から $n$ までの順列の中で長さ $r - l + 1$ で生成できる最小値、最大値を考える。  
	以下、$k = r - l + 1$ として扱う。
	
	*最小値*  
	初項 1、 項数 $m$ 、公差 1 の等差数列としてみると、  
	$min(m) = \frac{m(m + 1)}{2}$
	が導かれる。
	
	*最大値*  
	初項 $x$ 、項数 $m$ 、公差 -1 の等差数列としてみると、

	
	$max(x, m) = \frac{m * (2 * x + (m - 1) * -1)}{2}$  
	$max(x, m) = \frac{m(2x - m + 1)}{2}$
	
	が導かれる。

	$min(k) \leq s \leq max(n, k)$ の間にある $s$ は条件を満たすことがわかる。
	残るは実装のみで、$n$ から大きい順に 指定の配列に入れるか入れないかを決めていけば良い。

	*方針*
	初めに答えを入れる用の配列 $res$ を用意する。
	次に $n$ から大きい順に考えていく。
	$n$ からfor 文を回し、
	$max(i, k) - s \geq 0$ かつ $s - i \geq min(k - 1)$ を満たすならば
	配列 $res$ の $l + k$ に $i$ を代入、$k = k - 1, s = s - i$ で置き換える。
	これを $k$ が 0 になるまで繰り返し、最終的に $s = 0$ が達成できれば OK である。
	あとは配列の空いている部分に使用していない文字を代入していけば良い。

	[[https://codeforces.com/contest/1512/submission/115426822][提出したソースコード]]
** DONE Rust(lettre)とさくらのメールボックスでメール送信              :@Rust:
   :PROPERTIES:
   :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml
   :EXPORT_FILE_NAME: rust-lettre-sakura-mailbox.jp.md
   :EXPORT_DATE: 2021-06-01
   :EXPORT_HUGO_LASTMOD: 2021-06-01
   :EXPORT_HUGO_SECTION_FRAG: Development
   :EXPORT_HUGO_SECTION*: Development
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Rust lettre & さくらメールボックス"
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :math true
   :END:
   #+BEGIN_SRC yaml :front_matter_extra t
    menu:
     sidebar:
       name: Rust lettre
       identifier: rust-lettre
       parent: develop-jp
       weight: 10
	#+END_SRC
 
*** はじめに
	Rust の lettre クレートでさくらのメールボックスを用いて独自ドメインでのメールを送信する際の記録です。

	前提としては、
	- xdomain にて独自ドメインを取得済み
	- Netlify DNS にネームサーバを設定してる
	  
	  独自ドメインのメールアドレスでメールの送信がしたいが、ネームサーバは変更したくないというような状態です。
	
*** [[https://github.com/lettre/lettre][lettre]]
	Rust のメーラライブラリで、
	- SMTP(Simple Mail Transfer Protocol)を用いてセキュアなメールの送信ができる
	- ファイルの送信
	- 非同期サポート
	- ユニコードサポート
	  
	  などなど欲しい機能が一通り揃っています。
	  
*** さくらのメールボックスとは
	かの有名なさくらインターネットさんが用意されているプランの一つで、
	- 独自ドメインのメールが使える
	- 月額 87円（安すぎでは？）
	  
	  と主に月額にひかれて使い始めました。

*** やりたいこと
	[[https://www.sakura.ne.jp/mail/][さくらのメールボックスの登録]]、[[https://help.sakura.ad.jp/360000237321/#03][独自ドメインの追加]]、[[https://help.sakura.ad.jp/360000225362/#02][メールアドレスの作成]]は済んでいるものとします。
	Rust 内から lettre を使って独自ドメインからメールを送信しましょう。

	まず、公式のサンプルを見てみます。
	
	#+BEGIN_SRC rust
	  use lettre::transport::smtp::authentication::Credentials;
	  use lettre::{Message, SmtpTransport, Transport};

	  let email = Message::builder()
		  .from("NoBody <nobody@domain.tld>".parse().unwrap())
		  .reply_to("Yuin <yuin@domain.tld>".parse().unwrap())
		  .to("Hei <hei@domain.tld>".parse().unwrap())
		  .subject("Happy new year")
		  .body(String::from("Be happy!"))
		  .unwrap();

	  let creds = Credentials::new("smtp_username".to_string(), "smtp_password".to_string());

	  // Open a remote connection to gmail
	  let mailer = SmtpTransport::relay("smtp.gmail.com")
		  .unwrap()
		  .credentials(creds)
		  .build();

	  // Send the email
	  match mailer.send(&email) {
		  Ok(_) => println!("Email sent successfully!"),
		  Err(e) => panic!("Could not send email: {:?}", e),
	#+END_SRC

	ここで必要になるものが
	#+BEGIN_SRC rust
	  let creds = Credentials::new("smtp_username".to_string(), "smtp_password".to_string());

	  // Open a remote connection to gmail
	  let mailer = SmtpTransport::relay("smtp.gmail.com")
		  .unwrap()
		  .credentials(creds)
		  .build();
	#+END_SRC
	の部分です。
	
	初めに ~smtp_username~, ~smtp_password~ にそれぞれ独自ドメインを使用したメールアドレス、そのメールアドレス作成時のパスワードを設定します。
	ここでは、例としてメールアドレスが、 ~dummy@exmaple_domain.com~ でパスワードが、 ~dummy_password~ であるものとします。
	
	続いて、 ~mailer~ の接続情報ですが、ここに初期ドメインを設定します。アカウント情報から見れます。
	例として、 ~example.initial.domain.com~ としておきます。
	
	{{{color(red, git等にあげる際には、ドメイン情報やパスワード等を流出しないように気をつけてください。)}}}


	したがって、ソースコードは次のようになります。
	#+BEGIN_SRC rust
	  let creds = Credentials::new("dummy@example_domain.com".to_string(), "dummy_password".to_string());

	  // Open a remote connection
	  let mailer = SmtpTransport::relay("example.initial.domain.com")
		  .unwrap()
		  .credentials(creds)
		  .build();
	#+END_SRC

	しかし、このままではさくらのメールボックスを使った送信はできません。
	
	さくらのメールボックスではメールの暗号化通信に ~STARTTLS~ を使用します。
	したがって、mailer 部分を次のように改変します。
	#+BEGIN_SRC  rust
	  // Open a remote connection using STARTTLS
	  let mailer = SmtpTransport::starttls_relay("exmaple.initial.domain.com")
		  .unwrap()
		  .credentials(creds)
		  .build();
	#+END_SRC
	
	これにより lettre を経由して独自ドメインからメールの送信ができるようになりました。

	{{{color(red, git等にあげる際には、ドメイン情報やパスワード等を流出しないように気をつけてください。)}}}

	
*** 参考リンク
	- [[https://github.com/lettre/lettre][lettre github]]
	- [[https://midorimici.com/posts/dokuji-domain-mail-sakura-netlify/][みどりみちのブログ]]
	- [[https://www.sakura.ne.jp/mail/][さくらのメールボックス]]
	- [[https://help.sakura.ad.jp/360000237321/#03][さくらのレンタルサーバ（ドメインの設定）]]
	- [[https://help.sakura.ad.jp/360000225362/#02][さくらのレンタルサーバ（メールアドレスの作成）]]
** DONE GitLens for Emacs: Blamer.el                                 :@Emacs:
   :PROPERTIES:
   :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml
   :EXPORT_FILE_NAME: emacs-blamer.jp.md
   :EXPORT_DATE: 2022-12-16
   :EXPORT_HUGO_LASTMOD: 2022-12-17
   :EXPORT_HUGO_SECTION_FRAG: Development 
   :EXPORT_HUGO_SECTION*: Development
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Emacs Blamer.el"
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :math true
   :END:
   #+BEGIN_SRC yaml :front_matter_extra t
	 author:
	   name: Yudai Fukushima
	   image: /images/daifuku.webp
	 menu:
	  sidebar:
		name: Emacs Blamer
		identifier: emacs-blamer
		parent: develop-jp
		weight: 10
   #+END_SRC
   
   この記事は [[https://qiita.com/advent-calendar/2022/emacs][Emacs Advent Calendar 2022]] 17日目の記事です。
   
   *** はじめに

   VS Code を使ったことがある方なら誰しも一度は使用したことがあるであろうパッケージに [[https://gitlens.amod.io/][GitLens]] があります。
   これは、簡潔に言うとカーソルのある現在行や、クラスの先頭に Git Blame の情報を表示してくれるものです。
   以下に、VSCode での使用例を貼っておきます。

   [[/files/emacs-blamer/vscode.webp]]
   

   [[https://github.com/Artawower/blamer.el][Blamer.el]] は Artawower さんによって作成された Emacs 用の Git Blame プラグインです。

   #+BEGIN_QUOTE
   A git blame plugin for emacs inspired by VS Code’s GitLens plugin and Vim plugin
   #+END_QUOTE

   とあることからもわかるように、VSCode の GitLens や Vim の [[https://github.com/APZelos/blamer.nvim][Blamer.nvim]] プラグインと似た機能を持っています。

   日本語での記事が見当たらなかったため、この記事で軽く触れて行けたらと思っています。

   *** 設定例

   最初に自分が使用している設定例を載せておきます。

   #+BEGIN_SRC emacs-lisp
	 (use-package blamer
	   :ensure t
	   :custom
	   (blamer-idle-time 0.3)
	   (blamer-min-offset 70)
	   (blamer-pretty-time-p t)
	   (blamer-author-formatter "✎ %s ")
	   (blamer-datetime-formatter "[%s] ")
	   (blamer-commit-formatter "● %s")
	   (blamer-type 'visual)
	   :config
	   (global-blamer-mode 1))
   #+END_SRC
   
   実際の使用感は次のようになります。
   
   [[/files/emacs-blamer/current.webp]]


   カーソルのある行のコミット情報が表示されていることがわかると思います。
   
   *** 説明

   さらっと設定に触れていきます。

   - Git Blame の情報を表示するまでにかかる秒数の設定
	 ~(blamer-idle-time)~ にて設定することができます。
	 
   - 表示する際の著者・時刻・メッセージのフォーマットの設定

	 #+BEGIN_SRC emacs-lisp
	   (blamer-author-formatter "✎ %s ")    ;; 「✎ 著者名」と表示される
	   (blamer-datetime-formatter "[%s] ")  ;; 「[コミット作成日時] 」と表示される
	   (blamer-commit-formatter "● %s")     ;; 「● コミットメッセージ」 と表示される
	 #+END_SRC

	 コミット作成者・作成日時・コミットメッセージの表示フォーマットを設定することができます。
	 さらに、コミット作成日時に関しては、 ~(setq blamer-pretty-time-p t)~ とすることでいい感じにしてくれます。

   - コミット情報を表示するまでのオフセットの設定
	 ~(blamer-min-offset)~ にて設定することができます。
	 以下にオフセットを 10 に設定した場合の画像を貼っておきます。

	 [[/files/emacs-blamer/offset-10.webp]]

   - コミット情報の表示方法の設定
	 ~(blamer-type)~ にて設定することができ、次の 5 パターンの表示方法があります。
	 
     1. ~selected~ : マークされた各行に対してのコミット情報を表示します。

		[[/files/emacs-blamer/selected.webp]]

	 2. ~visual~ : カーソルがある現在行のコミット情報を表示します。

		[[/files/emacs-blamer/visual.webp]]

	 3. ~both~ : ~selected~ と ~visual~ 両方で情報を見ることが出来ます。

	 4. ~overlay-popup~ : 名前の通りです。 ~overlay-popup~ の場合は、表示位置を上下選ぶことができます。

	 5. ~posframe-popup~ : 同じく名前の通りです。

	 4, 5 に関しては、[[https://github.com/Artawower/blamer.el/tree/master/images][公式から画像]] が提供されています。
		   また、 ~selected~ の場合、 ~blamer-max-lines~ で表示する最大行数を設定することもできます。

   - ~blamer-show-commit-info~
	 ~M-x blamer-show-commit-info~ でコミット情報を表示することができます。

	 [[/files/emacs-blamer/show-commit-info.webp]]


  他にも、 ~uncommitted changes~ の表示メッセージを変更できたり、コミット上にマウスを置いた際に、ツールチップを表示させたり等、もっと多くのことができます。

  *** まとめ
  Emacs 用の GitLens パッケージ Blamer.el を紹介しました。
  良い Emacs ライフを！

  
  *** 参考リンク
  - [[https://github.com/Artawower/blamer.el][Artawower/blamer.el (GitHub)]]
  - [[https://github.com/granddaifuku/.emacs.d/blob/9a74af0a088d3d051ec78d61a93bb8c5124dc270/init.el#L635][自分の設定ファイルへのリンク (GitHub)]]
