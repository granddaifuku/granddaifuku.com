#+hugo_base_dir: .
#+hugo_section: /posts
#+author: Yudai Fukushima
#+hugo_auto_set_lastmod: t
#+OPTIONS: \n:t


* Blog Ideas
  :PROPERTIES:
  :VISIBILITY: children
  :END:
  
** DONE Codeforces #713(Div.3) <br> E: Permutation by Sum       :@Codeforces:
   :PROPERTIES:
   :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml
   :EXPORT_FILE_NAME: cf-713-div3-e
   :EXPORT_DATE: 2021-05-09
   :EXPORT_HUGO_LASTMOD: 2021-05-09
   :EXPORT_HUGO_SECTION*: Competitive
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :thumbnail "images/cf.png"
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Codeforces #713 E"
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :math true
   :END:
   #+BEGIN_SRC yaml :front_matter_extra t
    menu:
     sidebar:
       name: Codeforces 713 E
       identifier: cf-713-e
       parent: competitive
       weight: 10
	#+END_SRC
 
*** Problem Overview
	- Consider the permutation 1 to $n$ called $P$.
	- The parameters $l, r, s$ that satisfies $1 \leq l \leq r \leq n$ and $1 \leq s \leq \frac{n(n + 1)}{2}$ are given.
	- Find the permutation which satisfies $P_{l} + P_{l + 1} + ... + P_{r} = s$.
	- Print any permutation of length $n$ that fits the condition above if such a permutation exists; otherwise, -1.
	  
*** Problem Explanation
	First, consider the minimum and the maximum value we can generate with the length $r - l + 1$.  
	Hereafter, we define $k = r - l + 1$.  

	*Minimum Value*
	As an arithmetic sequence with first term 1, term number $m$, and tolerance 1, we can derive the minimum value.
	$min(m) = \frac{m(m + 1)}{2}$

	*Maximum Value*
	As an arithmetic sequence with first term $x$, term number $m$, and tolerance -1, we can derive the maximum value.

	$max(x, m) = \frac{m * (2 * x + (m - 1) * -1)}{2}$  
	$max(x, m) = \frac{m(2x - m + 1)}{2}$

	Any number $s$ that satisfies $min(k) \leq s \leq max(n, k)$ meet the condition.

	*Coding*
	First, we prepare the vector $res$ with size $n$ to push the results.
	Consider in descending order.
	Start the for loop from $n$,
	if $i$ meets the condition $max(i, k) - s \geq 0$ and $s - i \geq min(k - 1)$, put $i$ to the $res[l + k]$ and replace $k = k - 1, s = s - i$.
	Iterate this until $k$ becomes 0, and then if $s = 0$ is achieved, we find the permuation; otherwise, prints -1.
	The remaining part of the implementation is to insert the unused numbers into the empty parts of the vector.

	[[https://codeforces.com/contest/1512/submission/115426822][Source Code]]
** DONE TopCoder SRM 676 Div.1 Easy: Water Tank :@TopCoder:
   :PROPERTIES:
   :EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml
   :EXPORT_FILE_NAME: tc-676-div1-250
   :EXPORT_DATE: 2021-09-21
   :EXPORT_HUGO_LASTMOD: 2021-09-21
   :EXPORT_HUGO_SECTION*: Competitive
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "TopCoder SRM 676 Div.1 Easy"
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :math true
   :END:
   #+BEGIN_SRC yaml :front_matter_extra t
    menu:
     sidebar:
       name: TopCoder 676 Div1 250
       identifier: tc-676-div1-250
       parent: competitive
       weight: 10
	#+END_SRC
   
*** Overview
	- You are given an empty water tank with a capacity of $C$ liters.
	- Into this tank, the water flows $x[i]$ liters for $t[i]$ seconds. ($i = 0$ to $n - 1$)
	- You can set the value of output pipe to any maximum output rate $R$ (not negative value, but do not have to be an integer) in liters per second.
	- Determine the most little output rate limit $R$ such that the amount of water in the tank will never exceed $C$ liters.
	  
*** Explanation
	- When it comes to "Find the maximum of the minimum," we can use *Binary Search*.
	- The returning value can be double, so we apply binary search until the difference between the left and the right value becomes less than the acceptable error.

*** Code
	#+BEGIN_SRC C++
	  const double EPS = 1e-9;
	  const Inf = 1e9;
	  double minOutputRate(vector<int> t, vector<int> x, int C) {
		int n = (int)t.size();
		double left = -EPS, right = Inf, mid;
		while (right - left > EPS) {
		  mid = (right + left) / 2;
		  double rem = 0.0;
		  bool ok = true;
		  for(int i = 0; i < n; i++) {
			rem += (x[i] - mid) * t[i];
			rem = max(rem, (double)0);
			if (rem > C) {
			  ok = false;
			  break;
			}
		  }
		  if (ok)
			right = mid;
		  else
			left = mid;
		}
		return right;
	  }
	#+END_SRC
